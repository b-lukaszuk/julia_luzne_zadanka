#+TITLE: Ch06. Odds and Addends
#+STARTUP: overview
#+STARTUP: indent
#+OPTIONS: \n: t

* Link to the chapter online
[[https://allendowney.github.io/ThinkBayes2/chap06.html][Chapter 6]]

* Warning
*The content of this file may be incorrect, erroneous and/or harmful. Use it at Your own risk.*

* Data Files
None so far

* Environment

#+BEGIN_SRC

println("Let's go.")

#+END_SRC

#+BEGIN_SRC

cd(joinpath(homedir(), "Desktop", "julia/luzne_zadanka/book4/ch06")

#+END_SRC

#+BEGIN_SRC

using Pkg
Pkg.activate(".")
Pkg.status()

#+END_SRC

* Imports

#+BEGIN_SRC

# none so far

#+END_SRC

* Pmf
** struct definition

#+BEGIN_SRC

len(collection) = length(collection)

mutable struct Pmf{T}
    names::Vec{T} # names of hypotheses
    priors::Vec{Flt} # priors for each hypothesis
    likelihoods::Vec{Flt} # likelihoods for each hypothesis
    posteriors::Vec{Flt} # posteriors for each hypothesis

    Pmf(ns::Vec{Int}, prs) =
        (len(ns) != len(prs)) ?
        error("length(names) must be equal length(priors)") :
        new{Int}(
            ns, (prs ./ sum(prs)), zeros(len(ns)), zeros(len(ns))
        )

    Pmf(ns::Vec{Flt}, prs) =
        (len(ns) != len(prs)) ?
        error("length(names) must be equal length(priors)") :
        new{Flt}(
            ns, (prs ./ sum(prs)), zeros(len(ns)), zeros(len(ns))
        )
end

function round3(x::Flt)::Flt
    return round(x, digits=3)
end

function getFirstN(v::Vec{A}, n::Int)::Str where A
    @assert 0 < n <= 10 "n must be in range [1-10]"
    vv::Vec{A} = first(v, n)
    vv = eltype(v) == Flt ? round3.(vv) : vv
    result::Str = join(string.(vv), ", ")
    return len(v) > n ? result * "..." : result
end

function Base.show(io::IO, pmf::Pmf)
    result::Str = "names: $(getFirstN(pmf.names, 10))\n"
    result = result * "priors: $(getFirstN(pmf.priors, 10))\n"
    result = result * "likelihoods: $(getFirstN(pmf.likelihoods, 10))\n"
    result = result * "posteriors: $(getFirstN(pmf.posteriors, 10))\n"
    print(io, result)
    return nothing
end

#+END_SRC

** helper fns

#+BEGIN_SRC

function pmf2df(pmf::Pmf{A})::Dfs.DataFrame where A<:Ufi
    return Dfs.DataFrame(
        (;
        names=pmf.names,
        priors=pmf.priors,
        likelihoods=pmf.likelihoods,
        posteriors=pmf.posteriors
         )
    )
end

function getPmfFromSeq(seq::Vec{T})::Pmf{T} where T<:Ufi
    counts::Dict{T,Int} = Sb.countmap(seq)
    sortedKeys::Vec{T} = keys(counts) |> collect |> sort
    sortedVals::Vec{Int} = [counts[k] for k in sortedKeys]
    return Pmf(sortedKeys, sortedVals)
end

function getFieldValsEqName(pmf::Pmf{T}, name::T, fieldName::Str, default) where T<:Ufi
    ind = findfirst(x -> x == name, getproperty(pmf, Symbol("names")))
    return isnothing(ind) ? default : getproperty(pmf, Symbol(fieldName))[ind]
end

function getPriorByName(pmf::Pmf{T}, name::T)::Float64 where T<:Ufi
    return getFieldValsEqName(pmf, name, "priors", 0.0)
end

function getPriorsByNames(pmf::Pmf{T}, names::Vec{T})::Vec{Float64} where T<:Ufi
    return map(n -> getPriorByName(pmf, n), names)
end

function setLikelihoods!(pmf::Pmf{T}, newLikelihoods::Vec{Float64})::Pmf{T} where T<:Ufi
    pmf.likelihoods = newLikelihoods
    return pmf
end

function setPosteriors!(pmf::Pmf{T}, newPosteriors::Vec{Float64})::Pmf{T} where T<:Ufi
    pmf.posteriors = newPosteriors
    return pmf
end

"""
        normalizes pmf.posteriors so they add up to 1
"""
function normalizePosteriors!(pmf::Pmf{T})::Pmf{T} where T<:Ufi
    pmf.posteriors = pmf.posteriors ./ sum(pmf.posteriors)
    return pmf
end

"""
        updates posteriors (priors .* likeliehoods)
        if normalize = true, then posteriors are normalized
"""
function bayesUpdate!(pmf::Pmf{T}, normalize::Bool)::Pmf{T} where T<:Ufi
    setPosteriors!(pmf, pmf.priors .* pmf.likelihoods)
    if normalize
        normalizePosteriors!(pmf)
    end
    return pmf
end

function getIndMaxField(pmf::Pmf{T}, field::String)::Int where T<:Ufi
    maxProb::Float64 = max(getproperty(pmf, Symbol(field))...)
    return findfirst(x -> x == maxProb, getproperty(pmf, Symbol(field)))
end

function getIndMaxPosterior(pmf::Pmf)::Int
    return getIndMaxField(pmf, "posteriors")
end

function getIndMaxPrior(pmf::Pmf)::Int
    return getIndMaxField(pmf, "priors")
end

function getNameMaxPrior(pmf::Pmf{T})::T where T<:Ufi
    return pmf.names[getIndMaxPrior(pmf)]
end

function getNameMaxPosterior(pmf::Pmf{T})::T where T<:Ufi
    return pmf.names[getIndMaxPosterior(pmf)]
end

function updatePosteriors!(pmf::Pmf{<:Ufi},
                           nameThatOccurred::Ufi)::Pmf{<:Ufi}
    hypos::Vec{<:Ufi} = pmf.names
    likelihoods::Vec{Flt} = 1 ./ hypos
    impossible::Bv = nameThatOccurred .> hypos
    likelihoods[impossible] .= 0.0
    setLikelihoods!(pmf, likelihoods)
    if all(pmf.posteriors .== 0) # posteriors are initialized with 0s
        return bayesUpdate!(pmf, true)
    else
        pmf.posteriors .*= pmf.likelihoods
        return normalizePosteriors!(pmf)
    end
end

function updatePosteriors!(pmf::Pmf{<:Ufi},
                           namesThatOccurred::Vec{<:Ufi})::Pmf{<:Ufi}
    foreach(n -> updatePosteriors!(pmf, n), namesThatOccurred)
    return pmf
end

function updateBinomial!(pmf::Pmf{<:Ufi},
                           events::Vec{A},
                           eventsProbs::Dict{A, Vec{Flt}})::Pmf{<:Ufi} where A
    pmf.likelihoods .= 1
    for e in events
        pmf.likelihoods .*= eventsProbs[e]
    end
    return bayesUpdate!(pmf, true)
end

function updateBinomial!(pmf::Pmf{<:Ufi}, k::Int, n::Int)::Pmf{<:Ufi}
    @assert n >= k >= 0 "n and k must be >= 0"
    xs::Vec{<:Ufi} = pmf.names
    likelihoods::Vec{Flt} = Dst.pdf.(Dst.Binomial.(n, xs), k)
    setLikelihoods!(pmf, likelihoods)
    return bayesUpdate!(pmf, true)
end

function drawPmf(pmf::Pmf{T}, drawFn!::Function, pmfFieldForYs::Str, title::Str,
                 xlabel::Str, ylabel::Str)::Cmk.Figure where T<:Ufi
    fig::Cmk.Figure = Cmk.Figure(size=(600, 400))
    ax::Cmk.Axis = Cmk.Axis(fig[1, 1], title=title, xlabel=xlabel, ylabel=ylabel)
    drawFn!(ax, pmf.names, getproperty(pmf, Symbol(pmfFieldForYs)))
    return fig
end

function drawPriors(pmf::Pmf{T}, drawFn!::Function, title::Str,
                    xlabel::Str, ylabel::Str)::Cmk.Figure where T<:Ufi
    return drawPmf(pmf, drawFn!, "priors", title, xlabel, ylabel)
end

function drawPosteriors(pmf::Pmf{T}, drawFn!::Function, title::Str,
                        xlabel::Str, ylabel::Str)::Cmk.Figure where T<:Ufi
    return drawPmf(pmf, drawFn!, "posteriors", title, xlabel, ylabel)
end

function getPosteriorLE(pmf::Pmf{T}, cutoffName::T)::Flt where T<:Ufi
    inds::Vec{Int} = findall((<=)(cutoffName), pmf.names)
    return sum(pmf.posteriors[inds])
end

function getPosteriorGT(pmf::Pmf{T}, cutoffName::T)::Flt where T<:Ufi
    inds::Vec{Int} = findall((>)(cutoffName), pmf.names)
    return sum(pmf.posteriors[inds])
end

function getPosteriorQuantile(pmf::Pmf{T}, prob::Flt)::Flt where T<:Ufi
    @assert 0 <= prob <= 1 "prob must be in range [0-1]"
    totalProb::Flt = 0
    for i in eachindex(pmf.posteriors)
        totalProb += pmf.posteriors[i]
        if totalProb >= prob
            return pmf.names[i]
        end
    end
    return -99.0
end

function getPosteriorCredibleInterval(pmf::Pmf{T}, prob::Flt)::Vec{Flt} where T<:Ufi
    intervalLow::Flt = 0.5 - prob/2
    intervalHigh::Flt = 0.5 + prob/2
    return getPosteriorQuantile.(Ref(pmf), [intervalLow, intervalHigh])
end

function drawPriorsPosteriors(pmf::Pmf{<:Ufi}, drawFn!::Function,
                              title::Str, xlabel::Str, ylabel::Str)::Cmk.Figure
    fig::Cmk.Figure = Cmk.Figure()
    ax::Cmk.Axis = Cmk.Axis(fig[1, 1], title=title, xlabel=xlabel, ylabel=ylabel)
    drawFn!(ax, pmf.names, pmf.priors, label="prior")
    drawFn!(ax, pmf.names, pmf.posteriors, label="posteriors")
    Cmk.axislegend();
    return fig
end

function drawProbsComparison(pmf1::Pmf{<:Ufi}, pmf2::Pmf{<:Ufi}, fieldName::Str,
                             drawFn!::Function, label1::Str, label2::Str,
                             title::Str, xlabel::Str, ylabel::Str)::Cmk.Figure
    fig::Cmk.Figure = Cmk.Figure()
    ax::Cmk.Axis = Cmk.Axis(fig[1, 1], title=title, xlabel=xlabel, ylabel=ylabel)
    ys1::Vec{Flt} = getproperty(pmf1, Symbol(fieldName))
    ys2::Vec{Flt} = getproperty(pmf2, Symbol(fieldName))
    drawFn!(ax, pmf1.names, ys1, label=label1)
    drawFn!(ax, pmf2.names, ys2, label=label2)
    Cmk.axislegend();
    return fig
end

#+END_SRC

** other fns

#+BEGIN_SRC

function rep(x::A, times::Int)::Vec{A} where A
    @assert times > 1 "times must be greater than 1"
    return [x for _ in 1:times]
end

function rep(v::Vec{A}, times::Vec{Int})::Vec{A} where A
    @assert (len(v) == len(times)) "length(v) not equal length(times)"
    @assert all(map((>)(0), times)) "times elts must be GT 0"
    result::Vec{A} = Vec{eltype(v)}(undef, sum(times))
    currInd::Int = 1
    for i in eachindex(v)
        for _ in 1:times[i]
            result[currInd] = v[i]
            currInd += 1
        end
    end
    return result
end

c(sth) = collect(sth)
str(sth) = string(sth)

#+END_SRC

* 6. Odds and Addends

This chapter talks about:

- odds
- Bayes's Rule
- addends (quantities being added)

Bayes’s Rule is convenient if you want to do a Bayesian update on paper or in
your head. It also sheds light on the important idea of evidence and how we can
quantify the strength of evidence.

* 6.1. Odds

Odds (or odds in favor) are defined as:

$Odds = \frac{p}{q} = \frac{p}{1-p}$

where:

- p - probability of a success
- q - probability of failure (1-p)

#+BEGIN_SRC

function getOdds(pSuccess::Flt)::Flt
    @assert 0 <= pSuccess <= 1 "pSuccess must be in range [0-1]"
    return pSuccess / (1-pSuccess)
end

#+END_SRC

Let's say p = 0.75 then odds are three to one (3:1) in favor:

#+BEGIN_SRC

getOdds(0.75)

#+END_SRC

When probabilities are low, it is more common to report the odds against rather
than the odds in favor. For example, if my horse has a 10% chance of winning,
the odds in favor are:

#+BEGIN_SRC

getOdds(0.1)

#+END_SRC

1:9, but odds against are 9:1, see:

#+BEGIN_SRC

getOdds(0.9)

#+END_SRC

We can also do the opposite transformation, below my (BL) conversion for practice

$odds = \frac{p}{1-p}$ # swap sides, result below

$\frac{p}{1-p} = odds$ # move /(1-p) to the other side with the opposite sign, result below

$p = odds * (1-p)$ # act on right side: multiply odds by (1-p), result below

$p = odds - odds * p$ # move (odds*p) to the left with the opposite sign, result below

$p + (odds * p) = odds$ # rewrite left side to different equivalent form, result below

$p * (1 + odds) = odds$ # move (1+odds) to the right with the opposite sign, result below

$p = odds / (1 + odds)$

The last formula can be enclosed into Julia's function:

#+BEGIN_SRC

function getProb(odds::Flt)::Flt
    @assert odds >= 0 "odds must be >= 0"
    return odds / (odds + 1)
end

#+END_SRC

For example, if the odds are 3/2, the probability is:

#+BEGIN_SRC

getProb(3/2)

#+END_SRC

If we represent odds, e.g. as counts we get:

#+BEGIN_SRC

# yes - num times it will happen, no - num times it won't happen
function getProb(yes::Int, no::Int)::Flt
    @assert yes >= 0 "yes must be >= 0"
    @assert no >= 0 "no must be > 0"
    return yes / (yes + no)
end

#+END_SRC

And:

#+BEGIN_SRC

getProb(3, 2)

#+END_SRC

It's worth to know odds, since some computations are easier to do with odds than
with probabilities.

* 6.2. Bayes's Rule

Bayes theorem is:

$P(H|D) = \frac{P(H) * P(D|H)}{P(D)}$


Writing odds(A) for odds in favor of A, we can express Bayes’s Theorem in “odds
form”:

$odds(A|D) = odds(A) * \frac{P(D|A)}{P(D|B)}$

Let's solve the cookies problem with it, i.e. we got 2 bowls of cookies. Bowl 1
contains 30/10 vanilla/chocolate cookies, Bowl 2 contains 20/20 vanilla
chocolate cookies. You choose one bowl at random and draw a cookie, the cookie
is vanilla. What is the probability that it came from Bowl 1?

#+BEGIN_SRC

priorOdds = 1/1 # odds(Bowl 1) one Bowl 1 and one Bowl 2
likelihoodRatio = (30/40) / (20/40) # P(vanilla | Bowl 1) / P(vanilla | Bowl 2)
postOdds = priorOdds * likelihoodRatio

#+END_SRC

Which after changing to probability is (compare with Chapter 3.3):

#+BEGIN_SRC

getProb(postOdds)

#+END_SRC
